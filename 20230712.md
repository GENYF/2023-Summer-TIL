## 팀 스터디
### 1. 무엇이 문제인가?

**강동우**

- 책에서 나온 정리함씨의 ‘옆 건물의 엘리베이터 시간을 뺏어오자’는 마냥 농담 같은 아이디어도 좋은 방법이 될 수 있었다는 것에 사소한 농담 같은 생각도 무시하면 안되겠다고 생각한다.
- 문제를 해결하는 방법을 떠올리는 데 있어 사소하지 않은 방법은 없다고 생각한다.

**민병창**

- 블로그 리뷰 : [https://mbspear.tistory.com/entry/대체-뭐가-문제야-리뷰-1](https://mbspear.tistory.com/entry/%EB%8C%80%EC%B2%B4-%EB%AD%90%EA%B0%80-%EB%AC%B8%EC%A0%9C%EC%95%BC-%EB%A6%AC%EB%B7%B0-1)
- “**유머 감각이 없는 사람의 문제를 해결하려고 노력하지 말라”가 인상 깊었다.**
    - 개인적으로 해석해 보기에는 아무리 말도 안 된다 생각되는 의견일지라도 아이디어를 던지는 과정이 중요하며, 다른 사람과의 대화를 통해 의외로 실현될 수도 있음을 알려주는 말이지 않나 싶다.

**송영범**

- 우리는 문제를 찾는 것 보다, 해결책을 찾는 것에 집중하는 경향이 많다.
- 문제라는 것이 눈에 보일만큼 명확하다면, 그것은 진정한 문제가 아닐 확률이 높다.
- 문제를 정확하게 정의하는 것은 매우 중요하다.

**정보영**

- 

**정희진**

- 기존의 문제를 제대로 확인하지 않았으면 좋지 않았을까
- 다른 사람에게도 이득이 될 수 있는 법을 놓쳤던 점이 아쉬웠다.

### 2. 그것은 어떤 문제인가?

**강동우**

- 문제를 너무 쉽게 해결한다면 상대방의 신뢰를 얻지 못할 수도 있다는 것이 인상깊었다.
- 어떠한 문제를 해결했어도 거기에 그치지 않아야 한다고 글쓴이가 말하는 것 같다고 느껴 그 점을 유의 깊게 생각했다.

**민병창**

- 블로그 리뷰 : [https://mbspear.tistory.com/entry/대체-뭐가-문제야-리뷰-1](https://mbspear.tistory.com/entry/%EB%8C%80%EC%B2%B4-%EB%AD%90%EA%B0%80-%EB%AC%B8%EC%A0%9C%EC%95%BC-%EB%A6%AC%EB%B7%B0-1)
- 문제를 해결했다고 끝이라고 생각해서는 안된다. 항상 답이 없음을 인식하고 있어야 하고, 문제에 대한 의문을 제기해야한다.

**송영범**

- 컴퓨터 분야에게 필요한 책이라는 것을 다시 한번 느꼈다.
- 우리의 전공이 소프트웨어지만, 모든 문제를 소프트웨어로 풀려고 하는 것은 적합하지 않다.
- 우리가 완벽하게 해결했다고 생각하는 문제와 해결책에도 언제나 허점과 문제점이 존재한다.
- 문제를 개선하기 위한 작업은 평생 이루어져야 한다.

**정보영**

- 

**정희진**

- 문제를 해결하더라도 끝이 아니라 계속 생각해야한다는 것을 느꼈다.
- 예를 들어 주어진 예제에 맞춰서는 해결하더라도 발생할 수 있는 문제에 대해서도 예상을 해야할 것 같다.

### 3. 정말로 무엇이 문제인가?

**강동우**

- 모든 문제는 인식하는 것과 바라는 것과의 차이이므로, 문제를 해결했을때 다른 문제가 야기될 수 있다. - 문제의 해결안은 다른 문제의 근원
- 여행의 좋은 점 중 하나가 기존에 보지 못한 새로운 것을 볼 수 있다는 것이라고 생각하는데, 이 것이 문제를 해결하는 방법을 생각하는 것에도 적용되는 것에 동의하며 읽었다.

**민병창**

- 블로그 리뷰 : [https://mbspear.tistory.com/entry/대체-뭐가-문제야-리뷰-1](https://mbspear.tistory.com/entry/%EB%8C%80%EC%B2%B4-%EB%AD%90%EA%B0%80-%EB%AC%B8%EC%A0%9C%EC%95%BC-%EB%A6%AC%EB%B7%B0-1)
- 여러 관점에 대해 생각해보며 문제에 접근하는 과정이 필요함을 느꼈다.
- 문제를 완전히 해결할 수 없으며, ‘**새로운 문제 우리가 해결한 문제보다 덜 상시길 바란다’**는 말이 인상 깊었다. 2부의 그것은 어떤 문제인가? 에서도 이야기했지만 항상 문제에 대한 의문을 제시하여 더 나은 수정 방안에 대해 고민 해야겠다고 느꼈다.

**송영범**

- 세상을 비판적으로 바라보는 사고는 문제를 찾기 위해 매우 중요하다.
- 문제의 해결책이 새로운 문제를 만들어낼 수 있다.
- 문제 해결을 위해서는 경험에 의존하는 것보다 새로운 사고를 하는 자세가 필요하다.

**정보영**

- 

**정희진**

- 다른 분들이 나의 의견을 이해하기 쉬워야한다고 생각
- 문제를 해결하더라도 부적합한 것은 계속해서 발생


## 개인 스터디

## 01 COS PRO 1급 C언어 4차

### **[4차] 문제1) 사전에서 단어찾기**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838677/4차-문제1-사전에서-단어찾기](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838677/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C1-%EC%82%AC%EC%A0%84%EC%97%90%EC%84%9C-%EB%8B%A8%EC%96%B4%EC%B0%BE%EA%B8%B0)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN (3906)
char* vowels[5] = {"A", "E", "I", "O", "U"};
char* words[3906];
int words_idx = 0;

void create_words(int lev, char* str) {
    words[words_idx++] = str;
    for (int i = 0; i < 5; i++) {
        if (lev < 5) {
            char* new_str = (char*)malloc(sizeof(char)*(lev+2));
            strcpy(new_str, str);
            strcat(new_str, vowels[i]);
            create_words(lev + 1, new_str);
        }
    }
}

int solution(char* word) {
    int answer = 0;
    words_idx = 0;
    create_words(0, "");
    for (int i = 0; i < words_idx; i++)
        if (strcmp(word, words[i]) == 0) {
            answer = i;
            break;
        }
    return answer;
}

int main() {
    char* word1 = "AAAAE";
    int ret1 = solution(word1);

    printf("solution 함수의 반환 값은 %d 입니다.\n", ret1);

    char* word2 = "AAAE";
    int ret2 = solution(word2);

    printf("solution 함수의 반환 값은 %d 입니다.\n", ret2);
    return 0;
}
```

### [4차] 문제2) 문자열 압축

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838678/4차-문제2-문자열-압축](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838678/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C2-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

char* solution(char* s) {
    char* answer = (char*)malloc(sizeof(char) * (strlen(s) * 2 + 1));
    int answer_idx = 0;
    char previous = tolower(s[0]);
    int counter = 1;

    for(int i=1; i<strlen(s); i++) {
        if(tolower(s[i]) == previous)
            counter++;
        else {
            answer[answer_idx++] = previous;
            answer[answer_idx++] = counter + '0';
            counter = 1;
            previous = tolower(s[i]);
        }
    }
    answer[answer_idx++] = tolower(previous);
    answer[answer_idx++] = counter + '0';
    answer[answer_idx++] = '\0';
    return answer;
}

int main() {
    char* s = "YYYYYbbbBbbBBBMmmM";
    char* ret = solution(s);

    printf("solution 함수의 반환 값은 %s 입니다.\n", ret);
}
```

### **[4차] 문제3) 스키장 최소 비용 구하기**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838679/4차-문제3-스키장-최소-비용-구하기](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838679/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C3-%EC%8A%A4%ED%82%A4%EC%9E%A5-%EC%B5%9C%EC%86%8C-%EB%B9%84%EC%9A%A9-%EA%B5%AC%ED%95%98%EA%B8%B0)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

long long solution(int one_day_price, int multi_day, int multi_day_price, long long n) {
    if(one_day_price * multi_day <= multi_day_price)
        return n * one_day_price;
    else
        return (n / multi_day) * multi_day_price + (n % multi_day) * one_day_price;
}

int main() {
    int one_day_price1 = 3;
    int multi_day1 = 5;
    int multi_day_price1 = 14;
    long long n1 = 6;
    long long ret1 = solution(one_day_price1, multi_day1, multi_day_price1, n1);

    printf("solution 함수의 반환 값은 %lld 입니다.\n", ret1);

    int one_day_price2 = 2;
    int multi_day2 = 3;
    int multi_day_price2 = 5;
    long long n2 = 11;
    long long ret2 = solution(one_day_price2, multi_day2, multi_day_price2, n2);

    printf("solution 함수의 반환 값은 %lld 입니다.\n", ret2);
}
```

### **[4차] 문제4) 마방진 문제**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838680/4차-문제4-마방진-문제](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838680/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C4-%EB%A7%88%EB%B0%A9%EC%A7%84-%EB%AC%B8%EC%A0%9C)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

typedef struct {
    int first;
    int second;
} Pair;

const int n = 4;

int* func_a(int matrix[][4]) {
    int* ret = (int*)malloc(sizeof(int)*(2));
    int idx = 0;
    bool exist[17] = {false};
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
                exist[matrix[i][j]] = true;
    for (int i = 1; i <= n * n; i++)
        if (exist[i] == false)
            ret[idx++] = i;
    return ret;
}

Pair* func_b(int matrix[][4]) {
    Pair* ret = (Pair*)malloc(sizeof(Pair)*(2));
    int idx = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (matrix[i][j] == 0) {
                ret[idx].first = i;
                ret[idx++].second = j;
            }
    return ret;
}

bool func_c(int matrix[][4]) {
    int sum = 0;
    for (int i = 1; i <= n * n; i++)
        sum += i;
    sum = sum / n;
    for (int i = 0; i < n; i++) {
        int row_sum = 0;
        int col_sum = 0;
        for (int j = 0; j < n; j++) {
            row_sum += matrix[i][j];
            col_sum += matrix[j][i];
        }
        if (row_sum != sum || col_sum != sum)
            return false;
    }
    int main_diagonal_sum = 0;
    int skew_diagonal_sum = 0;
    for (int i = 0; i < n; i++) {
        main_diagonal_sum += matrix[i][i];
        skew_diagonal_sum += matrix[i][n-1-i];
    }
    if (main_diagonal_sum != sum || skew_diagonal_sum != sum)
        return false;
    return true;
}

int* solution(int matrix[][4]) {
    int* answer = (int*)malloc(sizeof(int) * 6);
    int ans_idx = 0;
    Pair* coords = func_b(matrix);
    int* nums = func_a(matrix);

    matrix[coords[0].first][coords[0].second] = nums[0];
    matrix[coords[1].first][coords[1].second] = nums[1];
    if (func_c(matrix)) {
        for (int i = 0; i <= 1; i++) {
            answer[ans_idx++] = coords[i].first + 1;
            answer[ans_idx++] = coords[i].second + 1;
            answer[ans_idx++] = nums[i];
        }
    }
    else {
        matrix[coords[0].first][coords[0].second] = nums[1];
        matrix[coords[1].first][coords[1].second] = nums[0];
        for (int i = 0; i <= 1; i++) {
            answer[ans_idx++] = coords[1-i].first + 1;
            answer[ans_idx++] = coords[1-i].second + 1;
            answer[ans_idx++] = nums[i];
        }
    }
    return answer;
}

int main() {
    int matrix[4][4] = {{16,2,3,13},{5,11,10,0},{9,7,6,12},{0,14,15,1}};
    int* ret = solution(matrix);
    
    printf("solution 함수의 반환 값은 {");
    for (int i = 0; i < 6; i++) {
        if (i != 0) printf(",");
        printf("%d", ret[i]);
    }
    printf("} 입니다.\n");
}
```

### **[4차] 문제5) 규칙에 맞는 숫자 생성수강평 남기기**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838681/4차-문제5-규칙에-맞는-숫자-생성](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838681/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C5-%EA%B7%9C%EC%B9%99%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%88%AB%EC%9E%90-%EC%83%9D%EC%84%B1)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

char* reverse(char* number) {
    char* reverse_number = (char*)malloc(sizeof(char) * (strlen(number)+2));
    int j = 0;
    for(int i = strlen(number)-1; i >= 0; i--, j++)
        reverse_number[i] = number[j];
    reverse_number[j] = '\0';
    free(number);
    return reverse_number;
}

char* solution(int n) {
    char* answer = (char*)malloc(sizeof(char) * (n+1));
    for(int i = 0; i < n; i++) {
        answer[i] = '1' + i;
        answer[i+1] = '\0';
        answer = reverse(answer);
    }
    return answer;
}

int main() {
    int n = 5;
    char* ret = solution(n);    
    printf("solution 함수의 반환 값은 %s 입니다.\n", ret);
}
```

### **[4차] 문제6) 자아도취 수**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838682/4차-문제6-자아도취-수](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838682/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C6-%EC%9E%90%EC%95%84%EB%8F%84%EC%B7%A8-%EC%88%98)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

int power(int base, int exponent) {
    int val = 1;
    for (int i = 0; i < exponent; i++)
        val *= base;
    return val;
}

int* solution(int k) {
    int range = power(10, k);
    int count = 0;
    int* narcissistic_number = malloc(sizeof(int) * range);
    for (int i = range / 10; i < range; i++) {
        int current = i;
        int calculated = 0;
        while (current != 0) {
            calculated += power(current % 10, k);
            current /= 10;
        }
        if (calculated == i)
            narcissistic_number[count++] = i;
    }
    int* answer = malloc(sizeof(int) * count);
    for(int i = 0; i < count; i++)
        answer[i] = narcissistic_number[i];
    return answer;
}

int main() {
    int k = 3;
    int* ret = solution(k);

    printf("solution 함수의 반환 값은 [");
    for (int i = 0; i < 4; i++) {
        if (i != 0) printf(", ");
        printf("%d", ret[i]);
    }
    printf("] 입니다.\n");
}
```

### **[4차] 문제7) 사각형 넓이 증가량 구하기**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838683/4차-문제7-사각형-넓이-증가량-구하기](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838683/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C7-%EC%82%AC%EA%B0%81%ED%98%95-%EB%84%93%EC%9D%B4-%EC%A6%9D%EA%B0%80%EB%9F%89-%EA%B5%AC%ED%95%98%EA%B8%B0)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

typedef struct Point2D {
    int x;
    int y;
}Point2D;

typedef struct Rectangle{
    Point2D* LeftDown;
    Point2D* RightUp;
}Rectangle;

int solution(int x1, int y1, int x2, int y2, int plus_x, int plus_y){
    Point2D leftdown = {x1, y1};
    Point2D rightup = {x2, y2};
    Rectangle rect = {&leftdown, &rightup};
    
    int first_width = (rect.RightUp->x - rect.LeftDown->x) * (rect.RightUp->y - rect.LeftDown->y);
    
    rightup.x += plus_x;
    rightup.y += plus_y;
    
    int second_width = (rect.RightUp->x - rect.LeftDown->x) * (rect.RightUp->y - rect.LeftDown->y);
    
    return second_width - first_width;
}

int main() {
	int x1 = 1, y1 = 1, x2 = 5, y2 = 5, plus_x = 2, plus_y = 1;
	int ret = solution(x1, y1, x2, y2, plus_x, plus_y);

	printf("solution 함수의 반환 값은 %d 입니다.\n", ret);
	return 0;
}
```

### **[4차] 문제8) n번째로 작은 수 구하기**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838684/4차-문제8-n번째로-작은-수-구하기](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838684/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C8-n%EB%B2%88%EC%A7%B8%EB%A1%9C-%EC%9E%91%EC%9D%80-%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <math.h>

int solution(int card[], int card_len, int n) {
    int answer = 0;
	  
		int n_slice[card_len];
		int temp;
			
		// n을 만들 수 없는지 판별
		temp = n;
		for (int i = 0; i < card_len; i++) {
			n_slice[card_len - i - 1] = temp % 10;
			temp /= 10;
		}
	
		for (int i = 0; i < card_len; i++) {
			for (int j = 0; j < card_len; j++) {
				if (card[i] == n_slice[j]) {
					n_slice[j] = -1;
					break;
				}
			}
		}
	
		for (int i = 0; i < card_len; i++) {
			if (n_slice[i] != -1) {
				answer = -1;
				break;
			}
		}
	
		// n의 순서 계산
		if (answer != -1) {
			int pw = pow(10, card_len - 1);
			for (int i = n; i > pw; i--) {
				// i을 만들 수 없는지 판별
				int i_slice[card_len];
				temp = i;
				for (int j = 0; j < card_len; j++) {
					i_slice[card_len - j - 1] = temp % 10;
					temp /= 10;
				}

				temp = n;
				for (int j = 0; j < card_len; j++) {
					n_slice[card_len - j - 1] = temp % 10;
					temp /= 10;
				}

				for (int j = 0; j < card_len; j++) {
					for (int k = 0; k < card_len; k++) {
						if (i_slice[j] == n_slice[k]) {
							n_slice[k] = -1;
							break;
						}
					}
				}

				bool flag = true;
				for (int i = 0; i < card_len; i++) {
					if (n_slice[i] != -1) {
						flag = false;
						break;
					}
				}

				if (flag) {
					answer++;
				}
			}
		}
		
    return answer;
}

int main() {
    int card1[] = {1, 2, 1, 3};
    int card_len1 = 4;
    int n1 = 1312;
    int ret1 = solution(card1, card_len1, n1);

    printf("solution 함수의 반환 값은 %d 입니다.\n", ret1);
    int card2[] = {1, 1, 1, 2};
    int card_len2 = 4;
    int n2 = 1122;
    int ret2 = solution(card2, card_len2, n2);

    printf("solution 함수의 반환 값은 %d 입니다.\n", ret2);
}
```

### **[4차] 문제9) 분침과 시침의 각도 구하기**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838685/4차-문제9-분침과-시침의-각도-구하기](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838685/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C9-%EB%B6%84%EC%B9%A8%EA%B3%BC-%EC%8B%9C%EC%B9%A8%EC%9D%98-%EA%B0%81%EB%8F%84-%EA%B5%AC%ED%95%98%EA%B8%B0)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

char* solution(int hour, int minute) {
    char* answer = malloc(sizeof(char) * 7);
	
		int h_degree = 30 * hour;
		int m_degree = 6 * minute;
		int degree = h_degree - m_degree > 0 ? (h_degree - m_degree) : -1 * (h_degree - m_degree);
	
		int idx = 0;
		if (degree >= 100) {
			answer[idx++] = '0' + degree / 100;
			degree %= 10;
		}
		if (degree >= 10) {
			answer[idx++] = '0' + degree / 10;
			degree %= 10;
		}
		if (degree >= 0) {
			answer[idx++] = '0' + degree;
		}
	
		answer[idx++] = '.';
		answer[idx++] = '0';
		answer[idx++] = NULL;
		
    return answer;
}

int main() {
    int hour = 3;
    int minute = 0;
    char* ret = solution(hour, minute);
    printf("solution 함수의 반환 값은 %s 입니다.\n", ret);
}
```

### **[4차] 문제10) 소수의 세제곱이 몇개가 있나요**

[https://edu.goorm.io/learn/lecture/17298/cos-pro-1급-기출문제-c언어/lesson/838686/4차-문제10-소수의-세제곱이-몇개가-있나요](https://edu.goorm.io/learn/lecture/17298/cos-pro-1%EA%B8%89-%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C-c%EC%96%B8%EC%96%B4/lesson/838686/4%EC%B0%A8-%EB%AC%B8%EC%A0%9C10-%EC%86%8C%EC%88%98%EC%9D%98-%EC%84%B8%EC%A0%9C%EA%B3%B1%EC%9D%B4-%EB%AA%87%EA%B0%9C%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94)

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <math.h>

int solution(int a, int b) { 
    int answer = 0;
	  
		int idx = ceil(sqrt(a));
		bool second_flag = true;
		bool third_flag = true;
	
		while (idx < sqrt(b)) {
			// 소수 판별
			bool prime_flag = true;
			
			for (int i = 2; i < idx; i++) {
				if (idx % i == 0) {
					prime_flag = false;
					break;
				}
			}
			
			// 제곱수 카운팅
			int result = 0;
			if (prime_flag) {
				result = idx * idx;
				if (result >= a && result <= b && second_flag) {
					answer++;
				}
				else {
					second_flag = false;
				}
				
				result = idx * idx;
				if (result >= a && result <= b && third_flag) {
					answer++;
				}
				else {
					third_flag = false;
				}
			}
			
			if (!second_flag && !third_flag) {
				break;
			}
			
			idx++;
		}
	
    return answer;
}

int main() {
    int a = 6;
    int b = 30;
    int ret = solution(a, b);

    printf("solution 함수의 반환 값은 %d 입니다.\n", ret);
}
```
